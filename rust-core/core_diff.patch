diff --color -urN core_backup/src/panic/panic_info.rs core/src/panic/panic_info.rs
--- core_backup/src/panic/panic_info.rs	2024-09-04 20:36:16
+++ core/src/panic/panic_info.rs	2024-09-04 20:49:58
@@ -23,15 +23,12 @@
 #[lang = "panic_info"]
 #[stable(feature = "panic_hooks", since = "1.10.0")]
 #[derive(Debug)]
-pub struct PanicInfo<'a> {
-    payload: &'a (dyn Any + Send),
-    message: Option<&'a fmt::Arguments<'a>>,
-    location: &'a Location<'a>,
+pub struct PanicInfo {
     can_unwind: bool,
     force_no_backtrace: bool,
 }
 
-impl<'a> PanicInfo<'a> {
+impl PanicInfo {
     #[unstable(
         feature = "panic_internals",
         reason = "internal details of the implementation of the `panic!` and related macros",
@@ -39,14 +36,11 @@
     )]
     #[doc(hidden)]
     #[inline]
-    pub fn internal_constructor(
-        message: Option<&'a fmt::Arguments<'a>>,
-        location: &'a Location<'a>,
-        can_unwind: bool,
-        force_no_backtrace: bool,
-    ) -> Self {
-        struct NoPayload;
-        PanicInfo { location, message, payload: &NoPayload, can_unwind, force_no_backtrace }
+    pub fn internal_constructor(can_unwind: bool, force_no_backtrace: bool) -> Self {
+        PanicInfo {
+            can_unwind,
+            force_no_backtrace,
+        }
     }
 
     #[unstable(
@@ -56,9 +50,7 @@
     )]
     #[doc(hidden)]
     #[inline]
-    pub fn set_payload(&mut self, info: &'a (dyn Any + Send)) {
-        self.payload = info;
-    }
+    pub fn set_payload<'a>(&mut self, info: &'a (dyn Any + Send)) {}
 
     /// Returns the payload associated with the panic.
     ///
@@ -84,7 +76,7 @@
     #[must_use]
     #[stable(feature = "panic_hooks", since = "1.10.0")]
     pub fn payload(&self) -> &(dyn Any + Send) {
-        self.payload
+        &()
     }
 
     /// If the `panic!` macro from the `core` crate (not from `std`)
@@ -93,7 +85,7 @@
     #[must_use]
     #[unstable(feature = "panic_info_message", issue = "66745")]
     pub fn message(&self) -> Option<&fmt::Arguments<'_>> {
-        self.message
+        None
     }
 
     /// Returns information about the location from which the panic originated,
@@ -125,7 +117,7 @@
     pub fn location(&self) -> Option<&Location<'_>> {
         // NOTE: If this is changed to sometimes return None,
         // deal with that case in std::panicking::default_hook and core::panicking::panic_fmt.
-        Some(&self.location)
+        None
     }
 
     /// Returns whether the panic handler is allowed to unwind the stack from
@@ -157,17 +149,8 @@
 }
 
 #[stable(feature = "panic_hook_display", since = "1.26.0")]
-impl fmt::Display for PanicInfo<'_> {
-    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
-        formatter.write_str("panicked at ")?;
-        self.location.fmt(formatter)?;
-        if let Some(message) = self.message {
-            formatter.write_str(":\n")?;
-            formatter.write_fmt(*message)?;
-        } else if let Some(payload) = self.payload.downcast_ref::<&'static str>() {
-            formatter.write_str(":\n")?;
-            formatter.write_str(payload)?;
-        }
+impl fmt::Display for PanicInfo {
+    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {
         // NOTE: we cannot use downcast_ref::<String>() here
         // since String is not available in core!
         // The payload is a String when `std::panic!` is called with multiple arguments,
diff --color -urN core_backup/src/panic.rs core/src/panic.rs
--- core_backup/src/panic.rs	2024-09-04 20:36:16
+++ core/src/panic.rs	2024-09-04 20:42:42
@@ -38,7 +38,7 @@
     ($fmt:expr, $($arg:tt)+) => ({
         // Semicolon to prevent temporaries inside the formatting machinery from
         // being considered alive in the caller after the panic_fmt call.
-        $crate::panicking::panic_fmt($crate::const_format_args!($fmt, $($arg)+));
+        $crate::panicking::panic_fmt();
     }),
 }
 
@@ -59,7 +59,7 @@
     ($($t:tt)+) => ({
         // Semicolon to prevent temporaries inside the formatting machinery from
         // being considered alive in the caller after the panic_fmt call.
-        $crate::panicking::panic_fmt($crate::const_format_args!($($t)+));
+        $crate::panicking::panic_fmt();
     }),
 }
 
@@ -103,7 +103,7 @@
     ($($t:tt)+) => ({
         // Semicolon to prevent temporaries inside the formatting machinery from
         // being considered alive in the caller after the panic_fmt call.
-        $crate::panicking::panic_fmt($crate::const_format_args!($($t)+));
+        $crate::panicking::panic_fmt();
     }),
 }
 
diff --color -urN core_backup/src/panicking.rs core/src/panicking.rs
--- core_backup/src/panicking.rs	2024-09-04 20:36:16
+++ core/src/panicking.rs	2024-09-04 20:45:24
@@ -49,7 +49,7 @@
 #[lang = "panic_fmt"] // needed for const-evaluated panics
 #[rustc_do_not_const_check] // hooked by const-eval
 #[rustc_const_unstable(feature = "core_panic", issue = "none")]
-pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {
+pub const fn panic_fmt() -> ! {
     if cfg!(feature = "panic_immediate_abort") {
         super::intrinsics::abort()
     }
@@ -58,12 +58,10 @@
     // that gets resolved to the `#[panic_handler]` function.
     extern "Rust" {
         #[lang = "panic_impl"]
-        fn panic_impl(pi: &PanicInfo<'_>) -> !;
+        fn panic_impl(pi: &PanicInfo) -> !;
     }
 
     let pi = PanicInfo::internal_constructor(
-        Some(&fmt),
-        Location::caller(),
         /* can_unwind */ true,
         /* force_no_backtrace */ false,
     );
@@ -82,7 +80,7 @@
 // and unwinds anyway, we will hit the "unwinding out of nounwind function" guard,
 // which causes a "panic in a function that cannot unwind".
 #[rustc_nounwind]
-pub fn panic_nounwind_fmt(fmt: fmt::Arguments<'_>, force_no_backtrace: bool) -> ! {
+pub fn panic_nounwind_fmt(force_no_backtrace: bool) -> ! {
     if cfg!(feature = "panic_immediate_abort") {
         super::intrinsics::abort()
     }
@@ -91,13 +89,11 @@
     // that gets resolved to the `#[panic_handler]` function.
     extern "Rust" {
         #[lang = "panic_impl"]
-        fn panic_impl(pi: &PanicInfo<'_>) -> !;
+        fn panic_impl(pi: &PanicInfo) -> !;
     }
 
     // PanicInfo with the `can_unwind` flag set to false forces an abort.
     let pi = PanicInfo::internal_constructor(
-        Some(&fmt),
-        Location::caller(),
         /* can_unwind */ false,
         force_no_backtrace,
     );
@@ -117,14 +113,14 @@
 #[track_caller]
 #[rustc_const_unstable(feature = "core_panic", issue = "none")]
 #[lang = "panic"] // needed by codegen for panic on overflow and other `Assert` MIR terminators
-pub const fn panic(expr: &'static str) -> ! {
+pub const fn panic(_: &'static str) -> ! {
     // Use Arguments::new_v1 instead of format_args!("{expr}") to potentially
     // reduce size overhead. The format_args! macro uses str's Display trait to
     // write expr, which calls Formatter::pad, which must accommodate string
     // truncation and padding (even though none is used here). Using
     // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the
     // output binary, saving up to a few kilobytes.
-    panic_fmt(fmt::Arguments::new_const(&[expr]));
+    panic_fmt();
 }
 
 /// Like `panic`, but without unwinding and track_caller to reduce the impact on codesize.
@@ -132,16 +128,16 @@
 #[cfg_attr(feature = "panic_immediate_abort", inline)]
 #[lang = "panic_nounwind"] // needed by codegen for non-unwinding panics
 #[rustc_nounwind]
-pub fn panic_nounwind(expr: &'static str) -> ! {
-    panic_nounwind_fmt(fmt::Arguments::new_const(&[expr]), /* force_no_backtrace */ false);
+pub fn panic_nounwind(_: &'static str) -> ! {
+    panic_nounwind_fmt(/* force_no_backtrace */ false);
 }
 
 /// Like `panic_nounwind`, but also inhibits showing a backtrace.
 #[cfg_attr(not(feature = "panic_immediate_abort"), inline(never), cold)]
 #[cfg_attr(feature = "panic_immediate_abort", inline)]
 #[rustc_nounwind]
-pub fn panic_nounwind_nobacktrace(expr: &'static str) -> ! {
-    panic_nounwind_fmt(fmt::Arguments::new_const(&[expr]), /* force_no_backtrace */ true);
+pub fn panic_nounwind_nobacktrace(_: &'static str) -> ! {
+    panic_nounwind_fmt(/* force_no_backtrace */ true);
 }
 
 #[inline]
@@ -164,7 +160,7 @@
 #[track_caller]
 #[rustc_diagnostic_item = "unreachable_display"] // needed for `non-fmt-panics` lint
 pub fn unreachable_display<T: fmt::Display>(x: &T) -> ! {
-    panic_fmt(format_args!("internal error: entered unreachable code: {}", *x));
+    panic_fmt();
 }
 
 #[inline]
@@ -175,7 +171,7 @@
 #[cfg_attr(not(bootstrap), rustc_const_panic_str)]
 #[rustc_const_unstable(feature = "core_panic", issue = "none")]
 pub const fn panic_display<T: fmt::Display>(x: &T) -> ! {
-    panic_fmt(format_args!("{}", *x));
+    panic_fmt();
 }
 
 #[cfg_attr(not(feature = "panic_immediate_abort"), inline(never), cold)]
@@ -201,9 +197,6 @@
     }
 
     panic_nounwind_fmt(
-        format_args!(
-            "misaligned pointer dereference: address must be a multiple of {required:#x} but is {found:#x}"
-        ),
         /* force_no_backtrace */ false,
     )
 }
