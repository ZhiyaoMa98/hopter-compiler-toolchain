From 210e45c20b9866f193a3b960d620e9f15d528f31 Mon Sep 17 00:00:00 2001
From: Zhiyao Ma <zhiyao.ma.98@gmail.com>
Date: Fri, 9 Aug 2024 17:47:37 -0400
Subject: [PATCH] Prevent automatic `nounwind` deduction for functions.

---
 llvm/include/llvm/Transforms/IPO/Attributor.h |  46 +++---
 llvm/lib/Transforms/IPO/Attributor.cpp        |   2 +-
 .../Transforms/IPO/AttributorAttributes.cpp   | 156 +++++++++---------
 llvm/lib/Transforms/IPO/FunctionAttrs.cpp     |  42 ++---
 4 files changed, 123 insertions(+), 123 deletions(-)

diff --git a/llvm/include/llvm/Transforms/IPO/Attributor.h b/llvm/include/llvm/Transforms/IPO/Attributor.h
index 1da00acdf034..df9dd55cf59a 100644
--- a/llvm/include/llvm/Transforms/IPO/Attributor.h
+++ b/llvm/include/llvm/Transforms/IPO/Attributor.h
@@ -3390,35 +3390,35 @@ ChangeStatus clampStateAndIndicateChange(StateType &S, const StateType &R) {
 ///                       Abstract Attribute Classes
 /// ----------------------------------------------------------------------------
 
-struct AANoUnwind
-    : public IRAttribute<Attribute::NoUnwind,
-                         StateWrapper<BooleanState, AbstractAttribute>,
-                         AANoUnwind> {
-  AANoUnwind(const IRPosition &IRP, Attributor &A) : IRAttribute(IRP) {}
+// struct AANoUnwind
+//     : public IRAttribute<Attribute::NoUnwind,
+//                          StateWrapper<BooleanState, AbstractAttribute>,
+//                          AANoUnwind> {
+//   AANoUnwind(const IRPosition &IRP, Attributor &A) : IRAttribute(IRP) {}
 
-  /// Returns true if nounwind is assumed.
-  bool isAssumedNoUnwind() const { return getAssumed(); }
+//   /// Returns true if nounwind is assumed.
+//   bool isAssumedNoUnwind() const { return getAssumed(); }
 
-  /// Returns true if nounwind is known.
-  bool isKnownNoUnwind() const { return getKnown(); }
+//   /// Returns true if nounwind is known.
+//   bool isKnownNoUnwind() const { return getKnown(); }
 
-  /// Create an abstract attribute view for the position \p IRP.
-  static AANoUnwind &createForPosition(const IRPosition &IRP, Attributor &A);
+//   /// Create an abstract attribute view for the position \p IRP.
+//   static AANoUnwind &createForPosition(const IRPosition &IRP, Attributor &A);
 
-  /// See AbstractAttribute::getName()
-  const std::string getName() const override { return "AANoUnwind"; }
+//   /// See AbstractAttribute::getName()
+//   const std::string getName() const override { return "AANoUnwind"; }
 
-  /// See AbstractAttribute::getIdAddr()
-  const char *getIdAddr() const override { return &ID; }
+//   /// See AbstractAttribute::getIdAddr()
+//   const char *getIdAddr() const override { return &ID; }
 
-  /// This function should return true if the type of the \p AA is AANoUnwind
-  static bool classof(const AbstractAttribute *AA) {
-    return (AA->getIdAddr() == &ID);
-  }
+//   /// This function should return true if the type of the \p AA is AANoUnwind
+//   static bool classof(const AbstractAttribute *AA) {
+//     return (AA->getIdAddr() == &ID);
+//   }
 
-  /// Unique ID (due to the unique address)
-  static const char ID;
-};
+//   /// Unique ID (due to the unique address)
+//   static const char ID;
+// };
 
 struct AANoSync
     : public IRAttribute<Attribute::NoSync,
@@ -6090,7 +6090,7 @@ bool hasAssumedIRAttr(Attributor &A, const AbstractAttribute *QueryingAA,
     IsKnown = AA->isKnown(__VA_ARGS__);                                        \
     return true;                                                               \
   }
-    CASE(NoUnwind, AANoUnwind, );
+    // CASE(NoUnwind, AANoUnwind, );
     CASE(WillReturn, AAWillReturn, );
     CASE(NoFree, AANoFree, );
     CASE(NoCapture, AANoCapture, );
diff --git a/llvm/lib/Transforms/IPO/Attributor.cpp b/llvm/lib/Transforms/IPO/Attributor.cpp
index 847d07a49dee..1be45a87478d 100644
--- a/llvm/lib/Transforms/IPO/Attributor.cpp
+++ b/llvm/lib/Transforms/IPO/Attributor.cpp
@@ -3291,7 +3291,7 @@ void Attributor::identifyDefaultAbstractAttributes(Function &F) {
   if (IsIPOAmendable) {
 
     // Every function can be nounwind.
-    checkAndQueryIRAttr<Attribute::NoUnwind, AANoUnwind>(FPos, FnAttrs);
+    // checkAndQueryIRAttr<Attribute::NoUnwind, AANoUnwind>(FPos, FnAttrs);
 
     // Every function might be marked "nosync"
     checkAndQueryIRAttr<Attribute::NoSync, AANoSync>(FPos, FnAttrs);
diff --git a/llvm/lib/Transforms/IPO/AttributorAttributes.cpp b/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
index 3a9a89d61355..fc2b9a696f64 100644
--- a/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
+++ b/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
@@ -156,7 +156,7 @@ namespace llvm {
   }
 
 PIPE_OPERATOR(AAIsDead)
-PIPE_OPERATOR(AANoUnwind)
+// PIPE_OPERATOR(AANoUnwind)
 PIPE_OPERATOR(AANoSync)
 PIPE_OPERATOR(AANoRecurse)
 PIPE_OPERATOR(AANonConvergent)
@@ -2030,81 +2030,81 @@ struct AAPointerInfoCallSiteReturned final : AAPointerInfoFloating {
 /// -----------------------NoUnwind Function Attribute--------------------------
 
 namespace {
-struct AANoUnwindImpl : AANoUnwind {
-  AANoUnwindImpl(const IRPosition &IRP, Attributor &A) : AANoUnwind(IRP, A) {}
-
-  /// See AbstractAttribute::initialize(...).
-  void initialize(Attributor &A) override {
-    bool IsKnown;
-    assert(!AA::hasAssumedIRAttr<Attribute::NoUnwind>(
-        A, nullptr, getIRPosition(), DepClassTy::NONE, IsKnown));
-    (void)IsKnown;
-  }
-
-  const std::string getAsStr(Attributor *A) const override {
-    return getAssumed() ? "nounwind" : "may-unwind";
-  }
-
-  /// See AbstractAttribute::updateImpl(...).
-  ChangeStatus updateImpl(Attributor &A) override {
-    auto Opcodes = {
-        (unsigned)Instruction::Invoke,      (unsigned)Instruction::CallBr,
-        (unsigned)Instruction::Call,        (unsigned)Instruction::CleanupRet,
-        (unsigned)Instruction::CatchSwitch, (unsigned)Instruction::Resume};
-
-    auto CheckForNoUnwind = [&](Instruction &I) {
-      if (!I.mayThrow(/* IncludePhaseOneUnwind */ true))
-        return true;
-
-      if (const auto *CB = dyn_cast<CallBase>(&I)) {
-        bool IsKnownNoUnwind;
-        return AA::hasAssumedIRAttr<Attribute::NoUnwind>(
-            A, this, IRPosition::callsite_function(*CB), DepClassTy::REQUIRED,
-            IsKnownNoUnwind);
-      }
-      return false;
-    };
-
-    bool UsedAssumedInformation = false;
-    if (!A.checkForAllInstructions(CheckForNoUnwind, *this, Opcodes,
-                                   UsedAssumedInformation))
-      return indicatePessimisticFixpoint();
-
-    return ChangeStatus::UNCHANGED;
-  }
-};
-
-struct AANoUnwindFunction final : public AANoUnwindImpl {
-  AANoUnwindFunction(const IRPosition &IRP, Attributor &A)
-      : AANoUnwindImpl(IRP, A) {}
-
-  /// See AbstractAttribute::trackStatistics()
-  void trackStatistics() const override { STATS_DECLTRACK_FN_ATTR(nounwind) }
-};
-
-/// NoUnwind attribute deduction for a call sites.
-struct AANoUnwindCallSite final : AANoUnwindImpl {
-  AANoUnwindCallSite(const IRPosition &IRP, Attributor &A)
-      : AANoUnwindImpl(IRP, A) {}
-
-  /// See AbstractAttribute::updateImpl(...).
-  ChangeStatus updateImpl(Attributor &A) override {
-    // TODO: Once we have call site specific value information we can provide
-    //       call site specific liveness information and then it makes
-    //       sense to specialize attributes for call sites arguments instead of
-    //       redirecting requests to the callee argument.
-    Function *F = getAssociatedFunction();
-    const IRPosition &FnPos = IRPosition::function(*F);
-    bool IsKnownNoUnwind;
-    if (AA::hasAssumedIRAttr<Attribute::NoUnwind>(
-            A, this, FnPos, DepClassTy::REQUIRED, IsKnownNoUnwind))
-      return ChangeStatus::UNCHANGED;
-    return indicatePessimisticFixpoint();
-  }
-
-  /// See AbstractAttribute::trackStatistics()
-  void trackStatistics() const override { STATS_DECLTRACK_CS_ATTR(nounwind); }
-};
+// struct AANoUnwindImpl : AANoUnwind {
+//   AANoUnwindImpl(const IRPosition &IRP, Attributor &A) : AANoUnwind(IRP, A) {}
+
+//   /// See AbstractAttribute::initialize(...).
+//   void initialize(Attributor &A) override {
+//     bool IsKnown;
+//     assert(!AA::hasAssumedIRAttr<Attribute::NoUnwind>(
+//         A, nullptr, getIRPosition(), DepClassTy::NONE, IsKnown));
+//     (void)IsKnown;
+//   }
+
+//   const std::string getAsStr(Attributor *A) const override {
+//     return getAssumed() ? "nounwind" : "may-unwind";
+//   }
+
+//   /// See AbstractAttribute::updateImpl(...).
+//   ChangeStatus updateImpl(Attributor &A) override {
+//     auto Opcodes = {
+//         (unsigned)Instruction::Invoke,      (unsigned)Instruction::CallBr,
+//         (unsigned)Instruction::Call,        (unsigned)Instruction::CleanupRet,
+//         (unsigned)Instruction::CatchSwitch, (unsigned)Instruction::Resume};
+
+//     auto CheckForNoUnwind = [&](Instruction &I) {
+//       if (!I.mayThrow(/* IncludePhaseOneUnwind */ true))
+//         return true;
+
+//       if (const auto *CB = dyn_cast<CallBase>(&I)) {
+//         bool IsKnownNoUnwind;
+//         return AA::hasAssumedIRAttr<Attribute::NoUnwind>(
+//             A, this, IRPosition::callsite_function(*CB), DepClassTy::REQUIRED,
+//             IsKnownNoUnwind);
+//       }
+//       return false;
+//     };
+
+//     bool UsedAssumedInformation = false;
+//     if (!A.checkForAllInstructions(CheckForNoUnwind, *this, Opcodes,
+//                                    UsedAssumedInformation))
+//       return indicatePessimisticFixpoint();
+
+//     return ChangeStatus::UNCHANGED;
+//   }
+// };
+
+// struct AANoUnwindFunction final : public AANoUnwindImpl {
+//   AANoUnwindFunction(const IRPosition &IRP, Attributor &A)
+//       : AANoUnwindImpl(IRP, A) {}
+
+//   /// See AbstractAttribute::trackStatistics()
+//   void trackStatistics() const override { STATS_DECLTRACK_FN_ATTR(nounwind) }
+// };
+
+// /// NoUnwind attribute deduction for a call sites.
+// struct AANoUnwindCallSite final : AANoUnwindImpl {
+//   AANoUnwindCallSite(const IRPosition &IRP, Attributor &A)
+//       : AANoUnwindImpl(IRP, A) {}
+
+//   /// See AbstractAttribute::updateImpl(...).
+//   ChangeStatus updateImpl(Attributor &A) override {
+//     // TODO: Once we have call site specific value information we can provide
+//     //       call site specific liveness information and then it makes
+//     //       sense to specialize attributes for call sites arguments instead of
+//     //       redirecting requests to the callee argument.
+//     Function *F = getAssociatedFunction();
+//     const IRPosition &FnPos = IRPosition::function(*F);
+//     bool IsKnownNoUnwind;
+//     if (AA::hasAssumedIRAttr<Attribute::NoUnwind>(
+//             A, this, FnPos, DepClassTy::REQUIRED, IsKnownNoUnwind))
+//       return ChangeStatus::UNCHANGED;
+//     return indicatePessimisticFixpoint();
+//   }
+
+//   /// See AbstractAttribute::trackStatistics()
+//   void trackStatistics() const override { STATS_DECLTRACK_CS_ATTR(nounwind); }
+// };
 } // namespace
 
 /// ------------------------ NoSync Function Attribute -------------------------
@@ -12064,7 +12064,7 @@ struct AAAddressSpaceCallSiteArgument final : AAAddressSpaceImpl {
 };
 } // namespace
 
-const char AANoUnwind::ID = 0;
+// const char AANoUnwind::ID = 0;
 const char AANoSync::ID = 0;
 const char AANoFree::ID = 0;
 const char AANonNull::ID = 0;
@@ -12191,7 +12191,7 @@ const char AAAddressSpace::ID = 0;
     return *AA;                                                                \
   }
 
-CREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANoUnwind)
+// CREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANoUnwind)
 CREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANoSync)
 CREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANoRecurse)
 CREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAWillReturn)
diff --git a/llvm/lib/Transforms/IPO/FunctionAttrs.cpp b/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
index 34299f9dbb23..d4d5a591f1f5 100644
--- a/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
+++ b/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
@@ -1500,27 +1500,27 @@ static void inferAttrsFromFunctionBodies(const SCCNodeSet &SCCNodes,
                                          SmallSet<Function *, 8> &Changed) {
   AttributeInferer AI;
 
-  if (!DisableNoUnwindInference)
-    // Request to infer nounwind attribute for all the functions in the SCC if
-    // every callsite within the SCC is not throwing (except for calls to
-    // functions within the SCC). Note that nounwind attribute suffers from
-    // derefinement - results may change depending on how functions are
-    // optimized. Thus it can be inferred only from exact definitions.
-    AI.registerAttrInference(AttributeInferer::InferenceDescriptor{
-        Attribute::NoUnwind,
-        // Skip non-throwing functions.
-        [](const Function &F) { return F.doesNotThrow(); },
-        // Instructions that break non-throwing assumption.
-        [&SCCNodes](Instruction &I) {
-          return InstrBreaksNonThrowing(I, SCCNodes);
-        },
-        [](Function &F) {
-          LLVM_DEBUG(dbgs()
-                     << "Adding nounwind attr to fn " << F.getName() << "\n");
-          F.setDoesNotThrow();
-          ++NumNoUnwind;
-        },
-        /* RequiresExactDefinition= */ true});
+  // if (!DisableNoUnwindInference)
+  //   // Request to infer nounwind attribute for all the functions in the SCC if
+  //   // every callsite within the SCC is not throwing (except for calls to
+  //   // functions within the SCC). Note that nounwind attribute suffers from
+  //   // derefinement - results may change depending on how functions are
+  //   // optimized. Thus it can be inferred only from exact definitions.
+  //   AI.registerAttrInference(AttributeInferer::InferenceDescriptor{
+  //       Attribute::NoUnwind,
+  //       // Skip non-throwing functions.
+  //       [](const Function &F) { return F.doesNotThrow(); },
+  //       // Instructions that break non-throwing assumption.
+  //       [&SCCNodes](Instruction &I) {
+  //         return InstrBreaksNonThrowing(I, SCCNodes);
+  //       },
+  //       [](Function &F) {
+  //         LLVM_DEBUG(dbgs()
+  //                    << "Adding nounwind attr to fn " << F.getName() << "\n");
+  //         F.setDoesNotThrow();
+  //         ++NumNoUnwind;
+  //       },
+  //       /* RequiresExactDefinition= */ true});
 
   if (!DisableNoFreeInference)
     // Request to infer nofree attribute for all the functions in the SCC if
-- 
2.39.3 (Apple Git-146)

